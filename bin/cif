#!/usr/bin/env python3
#
# cif client - Connects to the cif REST API
#
__author__ = 'James DeVincentis <james.d@hexhost.net>'

import argparse
import os
import sys
import json
import csv
import xml.etree.cElementTree

import requests
import requests.exceptions
import yaml
import tabulate

parser = argparse.ArgumentParser(description='Collective Intelligence Framework Client',
                                 formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('--url', dest='url', nargs='?', type=str, default='http://127.0.0.1:8080',
                    help='CIF REST API URL for connections')
parser.add_argument('query', type=str, help="HTTP query_string style query.")
parser.add_argument('--config', type=str, help="Configuration file path.", default="~/.cif")
parser.add_argument('--token', type=str, help="Token used for authentication.")
group = parser.add_argument_group('Query Options')
group.add_argument('--start', type=int, help="Start at record")
group.add_argument('--count', type=int, help="Get this many records")
group.add_argument('--chunk-size', type=int, help="Get x records at a time from the backend", default=10000)

# Debugging options not supported yet
# group = parser.add_argument_group('Debugging Options')
# group.add_argument('--show-request', dest='show_request', action="store_true",
#                   help='Shows the HTTP headers used when making the request')
# group.add_argument('--show-response', dest='show_response', action="store_true",
#                   help='Shows the HTTP headers the server responded with')

group = parser.add_argument_group('Output Options')
group.add_argument('--format', dest='format', choices=['cli', 'json', 'xml', 'csv', 'custom', 'single'], default="cli",
                   help="Output in this format. Custom can be defined using --format-string 'column,column2,...', "
                        "single will use the first column specified in 'select', by default it is 'observable'")
group.add_argument('--select', dest='select', help='Comma separated list of columns to display.',
                   default='timestamp,otype,observable,tags')
group.add_argument('--format-string', dest='format_string',
                   help="Python style string for formatting. Requires --select. Example: '{0},{1},{2}'")
group.add_argument('--write', dest='write', help='Filename to write output to instead of stdout')

options = vars(parser.parse_args())
config = None

# Only overwrite non-command line existent options
config_path = os.path.expanduser(options['config'])
if os.path.exists(os.path.expanduser(options['config'])):
    with open(config_path, 'r') as stream:
        config = yaml.load(stream)
    for key, value in config.items():
        if key not in options or options[key] is None:
            options[key] = value

headers = {}

if options['start'] is None:
    options['start'] = 0

if options['count'] is not None:
    options['end'] = options['start'] + options['count']
    if options['start'] + options['chunk_size'] > options['end']:
        options['chunk_size'] = options['end'] - options['start']
else:
    options['end'] = None

if options["token"] is not None:
    headers['Authorization'] = options["token"]

results = []

while True:
    try:
        response = requests.get('{0}/observables?start={1}&count={2}&{3}'.format(
            options['url'], options['start'], options['chunk_size'], options['query']), headers=headers, stream=True
        )
    except requests.exceptions.ConnectionError as e:
        sys.stderr.write("[ERROR] Could not make request to CIF Server: {0}\n".format(e))
        sys.exit(1)

    if response.status_code == 200:

        try:
            result = json.loads(response.text)
            results.extend(result)
        except Exception as e:
            raise RuntimeError("Could not fetch results from successful query") from e

        options['start'] += len(result)

        if options['end'] is not None:
            if options['start'] >= options['end']:
                break
            elif options['start'] + options['chunk_size'] > options['end']:
                options['chunk_size'] = options['end'] - options['start']
        if len(result) < options['chunk_size']:
            break

    elif response.status_code == 404:
        break
    elif response.status_code == 401:
        raise RuntimeError("Invalid Authentication: {0}".format(response.text))

    elif response.status_code == 400:
        raise RuntimeError("Invalid Query: {0}".format(response.text))

if options['write'] is not None:
    output_handle = open(options['write'], 'wt', newline='')
else:
    output_handle = sys.stdout

if options['format'] == "cli":
    headers = options['select'].split(',')
    rows = []
    for result in results:
        row = []
        for header in headers:
            if header in result:
                if isinstance(result[header], list):
                    result[header] = ', '.join(result[header])
                row.append(result[header])
            else:
                row.append('')
        rows.append(row)
    output_handle.write(tabulate.tabulate(rows, headers=headers, tablefmt="psql")+"\n")
elif options['format'] == "json":
    output_handle.write(json.dumps(results)+"\n")
elif options['format'] == "xml":
    headers = options['select'].split(',')

    if options['write'] is not None:
        output_handle.close()
        output_handle = open(options['write'], 'wb')
    else:
        raise RuntimeError("XML output can only be written to a file.")

    observables = xml.etree.cElementTree.Element("observables")
    for result in results:
        observable = xml.etree.cElementTree.SubElement(observables, "observable")
        for header in headers:
            if isinstance(result[header], list):
                if not header.endswith('s'):
                        header += 's'
                sub = xml.etree.cElementTree.SubElement(observable, header)
                for value in result[header]:
                    xml.etree.cElementTree.SubElement(sub, header[:-1]).text = value
            else:
                xml.etree.cElementTree.SubElement(observable, header).text = result[header]

    tree = xml.etree.cElementTree.ElementTree(observables)
    tree.write(output_handle)

elif options['format'] == "csv":
    headers = options['select'].split(',')
    writer = csv.writer(output_handle)
    writer.writerow(headers)
    for result in results:
        row = []
        for header in headers:
            if header in result:
                if isinstance(result[header], list):
                    result[header] = ', '.join(result[header])
                row.append(result[header])
            else:
                row.append('')
        writer.writerow(row)
elif options['format'] == "custom":
    columns = options['select'].split(',')
    for result in results:
        row = []
        for column in columns:
            if column in result:
                row.append(result[column])
            else:
                row.append('')
        try:
            output_handle.write(options['format_string'].format(*row)+"\n")
        except Exception as e:
            raise RuntimeError("Could not use custom formatting. column count: {0}; row count: {1}.".format(
                len(columns), len(row))
            ) from e

elif options['format'] == "single":
    for result in results:
        if options['select'] in result:
            output_handle.write(result[options['select']]+"\n")
